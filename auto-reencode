#!/bin/bash

# https://trac.ffmpeg.org/wiki/Encode/H.264
# https://trac.ffmpeg.org/wiki/Hardware/VAAPI
# https://trac.ffmpeg.org/wiki/EncodingForStreamingSites
#
# Run in the dir containing the target files you wish to convert to x264.
# There are no arguments.
# The script will copy both the audio and video bitrates into the new file
# via metadata from ffprobe.

export BLD="\e[01m" RED="\e[01;31m" BLU="\e[01;34m" CYA="\e[01;36m" NRM="\e[00m"
export PATH_TEMP='/tmp/auto-reencode'
export BIT_VIDEO=6500
export BIT_AUDIO=128

command -v ffmpeg >/dev/null 2>&1 || {
  echo -e "${BLD}${RED}I require ffmpeg but it's not installed. Aborting.${NRM}" >&2
  exit 1
}

command -v ffprobe >/dev/null 2>&1 || {
  echo -e "${BLD}${RED}I require ffmpeg but it's not installed. Aborting.${NRM}" >&2
  exit 1
}

report() {
  echo -e "${BLD}${CYA}Task $n of $total${NRM}"
  echo -e "${BLD} file to encode         : ${BLU}${file}${NRM}"
  echo -e "${BLD} current filesize       : ${fsize} MB${NRM}"
  echo -e "${BLD} video bitrate          : $vkbps kbps${NRM}"
  echo -e "${BLD} audio bitrate          : $akbps kbps${NRM}"
  echo -e "${BLD} play time              : $ptime secs${NRM}"
}

encode() {
  filename=$(basename -- "$file")
  basename=${filename%.*}

  mkdir -p ${PATH_TEMP} && ffmpeg \
    -y \
    -v fatal \
    -stats \
    -init_hw_device vaapi=intelgpu:/dev/dri/renderD128 \
    -hwaccel vaapi \
    -hwaccel_output_format vaapi \
    -hwaccel_device intelgpu \
    -i "${file}" \
    -filter_hw_device intelgpu \
    -vf 'format=nv12|vaapi,hwupload' \
    -c:v h264_vaapi \
    -bf 2 \
    -b:v "${vkbps}"k \
    -maxrate "${BIT_VIDEO}"k \
    -profile:v high \
    -level 5.1 \
    -threads 0 \
    -c:a libfdk_aac \
    -b:a "${akbps}"k \
    -c:s mov_text \
    -movflags +faststart \
    -f mp4 "${PATH_TEMP}/${basename}.m4v"

  mv "${PATH_TEMP}/${basename}.m4v" "${PWD}/".
}

mapfile -t files < <(find "${PWD}/"* -name '*.avi' -o -name '*.mp4' -o -name '*.wmv' -o -name '*.mkv' -o -name '*.flv' -o -name '*.mov')

total=${#files[@]}

for file in "${files[@]}"; do
  n=$((n + 1))

  # do not overwrite existing files
  if [[ -e "${file%.*}.m4v" ]]; then
    echo -e "${BLD}${RED} File already exists: ${file%.*}.m4v${NRM}"
    continue
  fi

  #  probe auto/video bitrate
  _vkbps=$(ffprobe -v error -select_streams v:0 -show_entries stream=bit_rate -of default=noprint_wrappers=1:nokey=1 "${file}")
  _akbps=$(ffprobe -v error -select_streams a:0 -show_entries stream=bit_rate -of default=noprint_wrappers=1:nokey=1 "${file}")
  ptime=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${file}")
  fsize=$(du -m "${file}" | awk '{print $1}')

  if [[ "$_vkbps" =~ ^-?[0-9]+$ ]]; then
    vkbps=$(echo "${_vkbps} / 1000" | bc)
  else
    # Base video bitrate of filesize when unable to probe bitrate
    vkbps=$(echo "(${fsize} * 8192) / (${ptime} + 0.5) / 1" | bc)
  fi

  if [[ "$_akbps" =~ ^-?[0-9]+$ ]]; then
    akbps=$(echo "${_akbps} / 1000" | bc)
  else
    akbps="${BIT_AUDIO}"
  fi

  report

  # Video bitrate over limit
  if [[ ${vkbps} -gt ${BIT_VIDEO} ]]; then
    vkbps="${BIT_VIDEO}"
    echo -e "${BLD} use video maxrate: ${vkbps} kbps${NRM}"
  fi

  # Audio bitrate over limit
  if [[ ${akbps} -gt ${BIT_AUDIO} ]]; then
    akbps="${BIT_AUDIO}"
    echo -e "${BLD} use audio bitrate: ${akbps} kbps${NRM}"
  fi

  # encode video
  if encode; then
    echo -e "${BLD} Encoding done${NRM}"
  else
    echo -e "${BLD}${RED} Encoding failed${NRM}"
  fi
done
